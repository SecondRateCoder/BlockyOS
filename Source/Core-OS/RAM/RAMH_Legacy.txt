#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

#pragma pack(push, 1)
#define OSBits (sizeof(void*) * 8)
#define ProcessIDSize IDSize
#define IDSize 8
#define pID_t _pID
#define ID_t _ID
#define ParentFlagsSize 3
#define TypeFlagsSize 5
#define MetadataBlockSize sizeof(size_t)*2 + sizeof(hcontext_t)
#define ramlength _ram_length - NumberOfBlocks * sizeof(size_t)
#define NumberOfBlocks HeaderMetadata->Size/(sizeof(size_t) *2)
#define h_pflags_t HeaderParentFlags
#define h_tflags_t HeaderTypeFlags
#define hcontext_t HeaderContext
#define header_t Header
#define hpeek_t HeaderAttrOffset
typedef struct _pID{uint8_t _pID[ProcessIDSize];    size_t *ProgramLocation_InMemory;}_pID;
typedef uint8_t _ID[IDSize];

//The start of RAM in Device Memory, with pre-defined space for the OS as well as thre length of RAM (with the OS taken into consideraion.).
extern uintptr_t _ram_start, _ram_length;
//A Pointer Table representation for RAM.
#define RAM RAM_
volatile uint8_t *RAM_ = (uint8_t *)&_ram_start;
//Points to free memory in RAM, grows downwards from RAM start.
volatile size_t *Pointer;
//A pointer stating how many memory blocks there are, grows upwards from the RAM end.
//It is in doubles, being: Context, PointerToLocation, SizeOfData.
volatile uint8_t *HeaderMetadata;

typedef void (*HeaderFunction)(header_t *H, void *args);

typedef struct Header{
    uint8_t *Data;
    hcontext_t Context;
}Header;
#pragma pop(pop)

typdef struct array{
    size_t Length;
    void *Array;
}array;

typedef struct HContext{
    //The ID for the Program that the Header is used by && The ID for the thread using Header.
    pID_t *ProgramID, *ThreadID;
    ID_t HeaderID;
    HeaderFlagsTuple Flags;
}HeaderContext;

typedef struct HeaderFlagsTuple{
    //The Parent(s) that the Header has, since it can only have 3 values.
    h_pflags_t ParentFlags[3];
    //The Type(s) and Arg(s) that the Header has, since it can only have 6 values.
    h_tflags_t TypeFlags[5];
    //Is the Data shared by multiple Threads/Programs, does the Header have multiple Type(s) and/or Arg(s).
    bool IsShared, IsMultipleTypes, IsProcess;
    
    unsigned int Permissions;
}HeaderFlagsTuple;


typedef enum HeaderFlags{
    Kernel =1,
    ChildProcess =2,
    Thread =3,
}HeaderParentFlags;

typedef enum HeaderFlags{
    ProgramBinaries =4,
    Encrypted =5,
    ProgramProtected =6,
    KernelProtected =7,
    Un_Protected =8,
    Data =9,
}HeaderTypeFlags;

typedef enum HeaderAttrOffset{
    //size_t
    HeaderAttrOffset_DataSize = 0,
    //size_t
    HeaderAttrOffset_NumberOfParentFlags = sizeof(size_t),
    //size_t
    HeaderAttrOffset_NumberOfTypeFlags = sizeof(size_t) * 2,
    //bool
    HeaderAttrOffset_IsMultipleTypes = sizeof(size_t) * 3,
    //bool
    HeaderAttrOffset_IsProcess = sizeof(size_t) * 3 + sizeof(bool),
    //bool
    HeaderAttrOffset_IsShared = sizeof(size_t) * 3 + sizeof(bool) *2,
    //int
    HeaderAttrOffset_Permissions = sizeof(size_t) * 3 + sizeof(bool) *3,
    //size_t
    HeaderAttrOffset_ProgramIDLocation = sizeof(size_t) * 3 + sizeof(bool) *3 + sizeof(int),
    //uint8_t[ProcessIDSize]
    HeaderAttrOffset_ProgramID = sizeof(size_t) * 4 + sizeof(bool) *3 + sizeof(int),
    //size_t
    HeaderAttrOffset_ThreadIDLocation = sizeof(size_t) * 3 + sizeof(bool) *3 + sizeof(int) *2 + ProcessIDSize,
    //uint8_t[ProcessIDSize]
    HeaderAttrOffset_ThreadID = sizeof(size_t) * 4 + sizeof(bool) *3 + sizeof(int) *2 + ProcessIDSize,
    //uint8_t[IDSize]
    HeaderAttrOffset_HeaderID = sizeof(size_t) * 4 + sizeof(bool) *3 + sizeof(int) *2 + ProcessIDSize *2,
    //The Flags and Data.
    HeaderAttrOffset_Pointers = sizeof(size_t) * 4 + sizeof(bool) *3 + sizeof(int) *2 + ProcessIDSize *2 + IDSize,
    //The Offset isn't used, here for differentiation.
    //This causes the function to retrieve the size of the header at runtime.
    HeaderAttrOffset_HeaderSize = 0xFFFF,
}HeaderAttrOffset;



uint8_t *header_peekunsafe(uint8_t *src, size_t Offset, hpeek_t PeekType);
uint8_t *header_peek(uint8_t *src, size_t Offset, pID_t ProgramID, hpeek_t PeekType);
header_t header_decodeRAM(size_t Index, pID_t ProgramID, ID_t ID);
header_t header_decode(uint8_t *src, size_t Offset, pID_t ProgramID, ID_t ID);
uint8_t *header_encodeRAM(header_t H);
uint8_t *header_encode(const header_t H);
void memcpy(uint8_t *dest, size_t Offset, const uint8_t *src, size_t size);
size_t memusage(pID_t *ProgramID, pID_t *ThreadID);
int memusage_count(pID_t *ProgramID, pID_t *ThreadID);
pID_t decode_id(uint8_t *array, size_t StartFrom);
size_t decode_size_t(const uint8_t *array, const int Offset);
int decode_int(const uint8_t *array, size_t Offset);
int *decode_int_array(const uint8_t *array, size_t Offset, const size_t Length);
uint8_t *slice_bytes(uint8_t *array, size_t start, size_t Length);
void encode_size_t(uint8_t *array, size_t value, size_t offset);
void encode_int(uint8_t *array, int value, size_t offset);
bool adrress_validate(size_t Index);
size_t usedmemory();
size_t clamp(size_t lower, size_t upper, size_t value);
bool space_validate(size_t address, size_t concurrent_size);
void encode_int(uint8_t *array, int value, size_t offset);